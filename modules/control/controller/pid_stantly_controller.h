/******************************************************************************
 * Copyright 2017 The JmcAuto Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *****************************************************************************/

/**
 * @file
 * @brief Defines the PID_STANTLY CONTROLLER class.
 */

#ifndef PID_STANTLY_CONTROLLER_H_
#define PID_STANTLY_CONTROLLER_H_

#include <fstream>
#include <memory>
#include <string>

#include "modules/common/configs/proto/vehicle_config.pb.h"

#include "modules/common/filters/digital_filter.h"
#include "modules/common/filters/digital_filter_coefficients.h"
#include "modules/common/filters/mean_filter.h"
#include "modules/control/common/trajectory_analyzer.h"
#include "modules/control/controller/controller.h"
#include "modules/control/common/pid_controller.h"
#include <map>


/**
 * @namespace jmc_auto::control
 * @brief jmc_auto::control
 */
namespace jmc_auto {
namespace control {

/**
 * @class Pid_Stantly Controller
 *
 * @brief Pid_Stantly Controller, to compute steering target with pid and stantly combined methed.
 */
class PidStantlyController : public Controller {
 public:
  /**
   * @brief constructor
   */
  PidStantlyController();

  /**
   * @brief destructor
   */
  virtual ~PidStantlyController();

  /**
   * @brief initialize Lateral Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  common::Status Init(const ControlConf *control_conf) override;

  /**
   * @brief compute steering target based on current vehicle status
   *        and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  common::Status ComputeControlCommand(
      const localization::LocalizationEstimate *localization,
      const canbus::Chassis *chassis, const planning::ADCTrajectory *trajectory,
      ControlCommand *cmd) override;

  /**
   * @brief reset Lateral Controller
   * @return Status reset status
   */
  common::Status Reset() override;

  /**
   * @brief stop Lateral controller
   */
  void Stop() override;

  /**
   * @brief Lateral controller name
   * @return string controller name in string
   */
  std::string Name() const override;

 protected:
  /*****************************
   * 获取车辆行驶方向航向角
   ****************************/
  void UpdateDrivingOrientation();
  
  void UpdateErrors(SimpleLateralDebug *debug);


  void ComputeErrors(const double x, const double y, const double theta,
                            const double preview_distance,
                            const TrajectoryAnalyzer &trajectory_analyzer,
                            SimpleLateralDebug *debug);
  bool LoadControlConf(const ControlConf *control_conf);
  void ProcessLogs(const SimpleLateralDebug *debug,
                   const canbus::Chassis *chassis);

  void CloseLogFile();
  void ComputeSteeringAngle(double & steering_angle_);
  // vehicle parameter
  const ControlConf *control_conf_ = nullptr;
  common::VehicleParam vehicle_param_;
  // a proxy to analyze the planning trajectory
  TrajectoryAnalyzer trajectory_analyzer_;
  const canbus::Chassis *chassis_ = nullptr;
  // the following parameters are vehicle physics related.
  const double rad_to_deg = 180 /M_PI ;
  // control time interval
  double ts_ = 0.0;
  // distance between front and rear wheel center
  double wheelbase_ = 0.0;
  // distance from rear wheel center to front wheel center
  double fr_ = 0.0 ;
  // the ratio between the turn of the steering wheel and the turn of the wheels
  double steer_transmission_ratio_ = 0.0;
  // the maximum turn of steer
  double steering_max_degree_ = 0.0;

  // for logging purpose
   FILE *steer_log_file_ = nullptr;

  const std::string name_;

  double minimum_speed_protection_ = 0.01;
  PIDController lateral_pid_controller_; 
  PIDController reverse_pid_controller_;
  double previous_steering_angle = 0.0 ;
  double driving_orientation = 0.0 ;
  double steering_angle = 0.0 ;
  double lookahead = 0.0 ;
  double lookback = 0.0 ;
  double kp = 0.0;
  double lateral_error = 0.0 ;
  double heading_error = 0.0 ;
  double lateral_compensation ;
  double heading_compensation ;
  double ksoft = 0.0 ;

};

}  // namespace control
}  // namespace jmc_auto

#endif  // MODULES_CONTROL_CONTROLLER_LATERAL_CONTROLLER_H_
